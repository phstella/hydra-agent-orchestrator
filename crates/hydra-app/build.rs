use std::fs;
use std::path::PathBuf;

use hydra_core::adapter::{AdapterTier, CapabilityConfidence, DetectStatus};

fn main() {
    if let Err(err) = generate_frontend_types() {
        panic!("failed to generate frontend shared types: {err}");
    }

    println!("cargo:rerun-if-changed=../hydra-core/src/adapter/types.rs");
    println!("cargo:rerun-if-changed=src/ipc_types.rs");
    tauri_build::build();
}

fn generate_frontend_types() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from("frontend/src/generated");
    fs::create_dir_all(&out_dir)?;

    let adapter_tiers = [AdapterTier::Tier1, AdapterTier::Experimental]
        .iter()
        .map(enum_literal)
        .collect::<Vec<_>>();
    let detect_statuses = [
        DetectStatus::Ready,
        DetectStatus::Blocked,
        DetectStatus::ExperimentalReady,
        DetectStatus::ExperimentalBlocked,
        DetectStatus::Missing,
    ]
    .iter()
    .map(enum_literal)
    .collect::<Vec<_>>();
    let confidence_levels = [
        CapabilityConfidence::Verified,
        CapabilityConfidence::Observed,
        CapabilityConfidence::Unknown,
    ]
    .iter()
    .map(enum_literal)
    .collect::<Vec<_>>();

    let check_statuses = ["passed", "failed", "warning", "running"]
        .iter()
        .map(|v| format!("\"{v}\""))
        .collect::<Vec<_>>();

    let generated = format!(
        "// @generated by crates/hydra-app/build.rs\n\
// Do not edit manually.\n\
\n\
export const ADAPTER_TIER_VALUES = [{adapter_tiers}] as const;\n\
export type AdapterTier = typeof ADAPTER_TIER_VALUES[number];\n\
\n\
export const DETECT_STATUS_VALUES = [{detect_statuses}] as const;\n\
export type DetectStatus = typeof DETECT_STATUS_VALUES[number];\n\
\n\
export const CAPABILITY_CONFIDENCE_VALUES = [{confidence_levels}] as const;\n\
export type CapabilityConfidence = typeof CAPABILITY_CONFIDENCE_VALUES[number];\n\
\n\
export const CHECK_STATUS_VALUES = [{check_statuses}] as const;\n\
export type CheckStatus = typeof CHECK_STATUS_VALUES[number];\n",
        adapter_tiers = adapter_tiers.join(", "),
        detect_statuses = detect_statuses.join(", "),
        confidence_levels = confidence_levels.join(", "),
        check_statuses = check_statuses.join(", "),
    );

    write_if_changed(out_dir.join("rust-enums.ts"), &generated)?;
    Ok(())
}

fn enum_literal<T: serde::Serialize>(value: &T) -> String {
    serde_json::to_string(value).expect("enum should serialize to string")
}

fn write_if_changed(path: PathBuf, contents: &str) -> Result<(), Box<dyn std::error::Error>> {
    match fs::read_to_string(&path) {
        Ok(existing) if existing == contents => Ok(()),
        _ => {
            fs::write(path, contents)?;
            Ok(())
        }
    }
}
